"use strict";

/*!
 * This file is part of kwarque.
 * Copyright(c) 2012 Ulf Hermann <ulf_hermann@gmx.net>
 * Licensed under AGPL v3, see COPYING
 */

var store = require('chat').io.store;
var db = require('pg');

var kwarque = require('kwarque');
var quadtree = require('quadtree');

var tree = quadtree.init({
    x : -20037508.34,
    y : -20037508.34,
    w : 20037508.34 * 2,
    h : 20037508.34 * 2,
    node : quadtree.backendNode
});

var config = {
    host : '/var/run/postgresql',
    database : 'kwarque'
};

var queries = {
    'getFragments'   : "SELECT id, x, y, title, text, owner, EXTRACT(EPOCH FROM time) AS time, EXTRACT(EPOCH FROM updated) AS timestamp" +
                       " FROM fragment" +
                       " WHERE x > $1 AND x < $3 AND y > $2 AND y < $4",
    'insertFragment' : "INSERT INTO fragment (x, y, title, text, time, owner) VALUES (" +
                       " $1, $2, $3, $4, TIMESTAMP 'EPOCH' + $5 * INTERVAL '1 SECONDS', $6)" +
                       " RETURNING id, EXTRACT(EPOCH FROM updated) AS timestamp",
    'checkLogin'     : "SELECT count(*) AS correct FROM account WHERE nick = $1 AND password = crypt ($2, password)",
    'register'       : "INSERT INTO account (nick, password) VALUES ($1, crypt($2, gen_salt('md5')))"
}
queries.getFragmentsByTime = queries.getFragments + " AND updated > TO_TIMESTAMP($5)";

store.subscribe('fragment', function(fragment) {
    tree.retrieve(fragment, function(clients) {
        for (var key in clients) {
            if (clients.hasOwnProperty(key)) {
                clients[key].emit('fragment', fragment);
            }
        }
    });
});

var query = function(name, values, row, end) {
    db.connect(config, function(err, client) {
        if (err) {
            if (end) end("error");
        } else {
            var q = client.query({
                name : name,
                text : queries[name],
                values : values
            });
            if (row) q.on("row", row);
            if (end) {
                q.on("end", function() {
                    end('end', end.id);
                });
                q.on("error", function(message) {
                    console.log(message);
                    end("error");
                });
            }
        }
    });
};

var getFragments = function(area, timestamp, row, end) {
    var params = [
        Math.floor(area.x),
        Math.floor(area.y),
        Math.ceil(area.x + area.w),
        Math.ceil(area.y + area.h),
    ];
    if (timestamp === null) {
        query('getFragments', params, row, end);
    } else {
        params.push(timestamp);
        query('getFragmentsByTime', params, row, end);
    }
};
        
var insertFragment = function(data, end) {
    query('insertFragment', [
        Math.round(data.x),
        Math.round(data.y),
        data.title,
        data.text,
        data.time,
        data.owner
    ], function(row) {
        end.id = row.id;
        end.timestamp = row.timestamp;
    }, end);
};

var checkLogin = function(loginData, end) {
    query('checkLogin', [
        loginData.nick,
        loginData.password
    ], end);
};

var register = function(loginData, end) {
    query('register', [
        loginData.nick,
        loginData.password
    ], null, end)
}

var ignore = function(client, fn) {
    for (var i = 0; i < client.watchedNodes.length - 1; ++i) {
        client.watchedNodes[i].remove(client.id);
    }
    client.watchedNodes.length = 0;
    fn('end');
}

kwarque.on('clientConnect', function(client) {
    client.watchedNodes = [];
    
    client.on("login", function(loginData, fn) {
        checkLogin(loginData, function(result) {
            if (result.correct) {
                client.set("nick", loginData.nick, function() {
                    client.nick = loginData.nick;
                    kwarque.emit('clientAuthenticate', client);
                    fn('end');
                });
            } else {
                fn('error');
            }
        });
    });
    
    client.on("register", function(loginData, fn) {
        register(loginData, function(result) {
            if (result !== 'error') {
                client.set("nick", loginData.nick, function() {
                    client.nick = loginData.nick;
                    kwarque.emit('clientAuthenticate', client);
                    fn(result);
                });
            } else {
                fn(result);
            }
        });
    });
    
    /**
     * watch an area on the map.
     */
    client.on("watch", function(selector, fn) {
        tree.prepare(selector.depth, selector.position, function(node, area) {
            node.insert(client.id, client);
            client.watchedNodes.push(node);
            getFragments(area, selector.timestamp, function(row) {
                client.emit('fragment', row);
            }, fn);
        });
    });

    /**
     * ignore the currently watched area on the map
     */
    client.on("ignore", function(data, fn) {ignore(client, fn);});
            
    client.on("insert", function(data, fn) {
        if (client.nick === null) {
            fn('error');
        } else {
            data.owner = client.nick;
            var handler = function(result) {
                fn(result, handler.id);
                data.id = handler.id;
                data.timestamp = handler.timestamp;
                data.w = 0;
                data.h = 0;
                tree.retrieve(data, function(clients) {
                    for (var key in clients) {
                        if (clients.hasOwnProperty(key)) {
                            clients[key].emit('fragment', data);
                        }
                    }
                });
                store.publish('fragment', data);
            };
            insertFragment(data, handler);
        }
    });
});

kwarque.on('clientDisconnect', function(client) {
    ignore(client, kwarque.noop);
});