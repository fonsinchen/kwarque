
(function(exports) {
    var TOP_LEFT     = 0;
    var TOP_RIGHT    = 1;
    var BOTTOM_LEFT  = 2;
    var BOTTOM_RIGHT = 3;
    var MAX_DEPTH    = 16; // due to shift operators only working on 32 bits

    var base_area = {
        init : function(x, y, w, h, depth) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            if (depth < MAX_DEPTH) {
                this.child = Object.create(base_area);
                this.child.init(x, y, w/2, h/2, depth + 1);
            }
        },

        descend : function(direction, callback) {
            switch (direction) {
                case BOTTOM_RIGHT:
                case BOTTOM_LEFT:
                    this.child.y = this.y + this.child.h;
                    break;
                default:
                    this.child.y = this.y;
            }
            switch (direction) {
                case TOP_RIGHT:
                case BOTTOM_RIGHT:
                    this.child.x = this.x + this.child.w;
                    break;
                default:
                    this.child.x = this.x;
            }
            callback(direction, this.child);
        },

        /**
         * Finds the regions the item overlaps with. See constants defined
         * above. The callback is called for every region the item overlaps.
         */
        find : function(item, callback) {
            // left
            if (item.x <= this.x + this.w / 2) {
                if (item.y <= this.y + this.h / 2) this.descend(TOP_LEFT, callback);
                if (item.y + item.h > this.y + this.h / 2) this.descend(BOTTOM_LEFT, callback);
            }
            // right
            if (item.x + item.w > this.x + this.w / 2) {
                if (item.y <= this.y + this.h / 2) this.descend(TOP_RIGHT, callback);
                if (item.y + item.h > this.y + this.h / 2) this.descend(BOTTOM_RIGHT, callback);
            }
        }
    }


    /* public methods:
     * - prepare: frontend creates nodes for area, backend recreates specified node
     * - retrieve: frontend retrieves nodes, backend retrieves items
     * - insert/update: backend inserts item, frontend updates timestamps
     * - clear: frontend removes subtree unconditionally, backend only if empty
     */
    var baseNode = function(depth, position, parent, node, shared) {
        shared.parent = parent;

        var that = {
            /**
             * Call the callback with the items of each node item overlaps with.
             */
            retrieve : function (item, area, callback) {
                shared.retrieve(callback);

                // check if node has subnodes
                if (shared.nodes !== undefined) {
                    // call retrieve on all matching subnodes
                    area.find(item, function(dir, area) {
                        shared.nodes[dir].retrieve(item, area, callback);
                    });
                }
            }
        };

        shared.getChildPosition = function(direction) {
            return position | (direction << (depth * 2));
        };

        shared.divide = function() {
            shared.nodes = [];
            for (var i = 0; i < 4; ++i) {
                shared.nodes.push(node(depth + 1, shared.getChildPosition(i), that, node))
            }
        };

        return that;
    }

    exports.init = function(config) {
        var area = Object.create(base_area);
        area.init(config.x, config.y, config.w, config.h, 0);
        return config.node(0, 0, null).bind(area);
    };

    exports.backendNode = function(depth, position, parent) {
        var items = null;
        var shared = {
            retrieve : function(callback) {
                if (items !== null) callback(items);
            }
        };
        var that = baseNode(depth, position, parent, exports.backendNode, shared);

        that.prepare = function(reqDepth, reqPosition, area, callback) {
            if (depth < reqDepth && depth < MAX_DEPTH) {
                if (shared.nodes === undefined) shared.divide();
                area.descend((reqPosition >> (depth * 2)) & 0x3, function(dir, area) {
                    shared.nodes[dir].prepare(reqDepth, reqPosition, area, callback);
                });
            } else {
                callback(that, area);
            }
            return that;
        };

        /**
         * Adds a new Item to the node. No checks needed for our special case.
         * TODO: we should make sure that no null, undefined, true, false and
         * the likes end up as keys here.
         */
        that.insert = function(key, val) {
            if (items === null) items = {};
            items[key] = val;
        };

        that.remove = function(key) {
            if (key !== undefined && key !== null) delete items[key];
            for (key in items) { // check for emptiness ... in a crude JSy way
                if (items.hasOwnProperty(key)) return false;
            }
            if (shared.nodes !== undefined) {
                var remove = true;
                for (var i = 0; i < 4; ++i) {
                    remove = remove && shared.nodes[i].remove();
                }
                if (!remove) return false;
                delete shared.nodes;
            }
            if (key !== undefined && shared.parent !== null) shared.parent.remove(null);
            return true;
        };


        that.bind = function(area) {
            return {
                retrieve : function(item, callback) {
                    return that.retrieve(item, area, callback);
                },
                prepare : function(depth, position, callback) {
                    return that.prepare(depth, position, area, callback);
                }
            }
        }
        return that;
    };

    exports.frontendNode = function(depth, position, parent) {
        var timestamp = null;
        var shared = {
            retrieve : function(callback) {callback(depth, position, timestamp);}
        };
        var that = baseNode(depth, position, parent, exports.frontendNode, shared);
        
        that.getTimestamp = function() {return timestamp};
        that.setTimestamp = function(newTimestamp) {timestamp = newTimestamp;};

        /**
         * Split the node until we get decently sized nodes for the given
         * area. Decently sized means the nodes' x and y extents must not
         * be larger than twice the item's, except if maxDepth is reached.
         * Call the callback with each of those nodes.
         */
        that.prepare = function(item, area, callback) {
            if (depth === MAX_DEPTH || (shared.nodes === undefined && (2 * item.w > area.w || 2 * item.h > area.h))) {
                callback(depth, position, timestamp);
            } else {
                if (shared.nodes === undefined) {
                    shared.divide();
                    for (var i = 0; i < 4; ++i) {
                        shared.nodes[i].setTimestamp(timestamp);
                    }
                }
                area.find(item, function(dir, area) {
                    shared.nodes[dir].prepare(item, area, callback);
                });
            }
            return that;
        };

        that.update = function(item, area) {
            if (shared.nodes === undefined) {
                if (item.timestamp > timestamp) {
                    timestamp = item.timestamp;
                    return true;
                } else {
                    return false;
                }
            } else {
                var do_check = true;
                area.find(item, function(dir, area) {
                    do_check = do_check && shared.nodes[dir].update(item, area);
                });
                if (do_check) {
                    var min = item.timestamp;
                    for (var i = 0; i < 4; ++i) {
                        min = Math.min(min, shared.nodes[i].getTimestamp());
                    }
                    if (min > timestamp) {
                        timestamp = min;
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            }
        }

        that.bind = function(area) {
            return {
                retrieve : function(item, callback) {
                    return that.retrieve(item, area, callback);
                },
                prepare : function(item, callback) {
                    return that.prepare(item, area, callback);
                },
                update : function(item) {
                    return that.update(item, area);
                }
            }
        }
        return that;
    };
})(typeof(exports) === "undefined" ? KWARQUE.quadtree = {} : exports)