"use strict";

/*!
 * This file is part of kwarque.
 * Copyright(c) 2012 Ulf Hermann <ulf_hermann@gmx.net>
 * Licensed under AGPL v3, see COPYING
 */

var kwarque = require('kwarque');
var io = require('socket.io').listen(kwarque.app);
    
/* remember nick of disconnecting clients */
var disconnectingNick = null;
var superDisconnect = io.onClientDisconnect;
io.onClientDisconnect = function(id, reason) {
    var client = io.sockets.socket(id);
    if (client) {
        kwarque.emit('clientDisconnect', client);
        client.get('nick', function(err, nick) {
            disconnectingNick = nick;
            superDisconnect.call(io, id, reason);
            disconnectingNick = null;
        });
    } else {
        superDisconnect.call(io, id, reason);
        disconnectingNick = null;
    }
};

var handleJoin = function(nick, room) {
    io.store.get(room, function(members) {
        if (typeof members === 'undefined') members = [];
        if (nick) members.push(nick);
        io.store.set(room, members);
    });
};

var handleLeave = function(nick, room) {
    io.store.get(room, function(members) {
        var pos = members.indexOf(nick);
        if (pos !== -1) {
            members.splice(pos, 1);
            io.store.set(room, members);
        }
    });
};

/* hook into onJoin and onLeave to generate messages for respective rooms */
var overrideHandler = function (name, eventName, handler) {
    var superHandler = io[name];
    io[name] = function(id, room) {
        superHandler.apply(io, [id, room]);
        room = room.split('/');
        room = room[room.length - 1];
        var client = io.sockets.socket(id);
        var handle = function(nick) {
            if (room) {
                handler(nick, room);
                if (nick) {
                    io.sockets["in"](room).except(id).emit(eventName, {
                        nick: nick,
                        room: room
                    });
                }
            }
        }
        if (client) {
            client.get('nick', function(err, nick) {
                handle(nick ? nick : disconnectingNick);
            });
        } else {
            handle(disconnectingNick);
        }
    }
};
overrideHandler('onJoin', 'clientJoined', handleJoin);
overrideHandler('onLeave', 'clientLeft', handleLeave);

//var redis = require('socket.io/node_modules/redis');

io.configure(function () {
/*    var RedisStore = require('socket.io/lib/stores/redis');
    io.set('store', new RedisStore({
        redisPub: redis.createClient(),
        redisSub: redis.createClient(),
        redisClient: redis.createClient()
    }));
*/
});

io.store.data = {};
io.store.get = function(key, callback) {
    // TODO: use redis if available
    callback(io.store.data[key]);
}

io.store.set = function(key, value) {
    // TODO: use redis if available
    io.store.data[key] = value;
}

io.sockets.on('connection', function (client) {
    client.nick = null;

    client.on("join", function (msg, fn) {
        var indicator = msg.room.substring(0,1);
        if (indicator === '@' || indicator === '#') {
            // only fragment and area chats for now
            client.join(msg.room);
            io.store.get(msg.room, fn);
        } else if (msg.room === '~') {
            // '~' is the private room, nothing to do there
            fn([client.nick]);
        } else {
            fn('error');
        }
    });

    client.on('leave', function (msg, fn) {
        client.leave(msg.room);
        fn('end');
    });

    client.on('message', function (msg, fn) {
        // if msg.nick is a number we always allow it
        // otherwise the nicks have to match
        if ((client.nick === msg.nick || +msg.nick > 0) &&
                client.manager.roomClients[client.id][client.namespace.name + '/' + msg.room] === true) {
            client.broadcast.to(msg.room).json.send(msg);
            fn(msg);
        } else {
            fn({
                nick : client.nick,
                room : msg.room,
                msg : 'failed to send "' + msg.msg + '".'
            })
        }
    });

    kwarque.emit('clientConnect', client);
});

kwarque.on('clientAuthenticate', function(client) {
    var rooms = client.manager.roomClients[client.id];
    for (var room in rooms) {
        if (rooms.hasOwnProperty(room)) {
            room = room.split('/');
            room = room[room.length - 1];
            io.store.get(room, function(members) {
                if (typeof members === 'undefined') {
                    members = [client.nick];
                } else {
                    members.push(client.nick);
                }
                io.store.set(room, members);
            });
            // broadcast to everyone including client
            io.sockets["in"](room).emit('clientJoined', {
                nick: client.nick,
                room: room
            });
        }
    }
});

exports.io = io;
