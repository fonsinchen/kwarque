"use strict";

/*!
 * This file is part of kwarque.
 * Copyright(c) 2012 Ulf Hermann <ulf_hermann@gmx.net>
 * Licensed under AGPL v3, see COPYING
 */

var kwarque = require('kwarque');
var io = require('socket.io').listen(kwarque.app);
    
/* remember nick of disconnecting clients */
var disconnectingNick = null;
var superDisconnect = io.onClientDisconnect;
io.onClientDisconnect = function(id, reason) {
    var client = io.sockets.socket(id);
    if (client) {
        kwarque.emit('clientDisconnect', client);
        client.get('nick', function(err, nick) {
            disconnectingNick = nick;
            superDisconnect.call(io, id, reason);
            disconnectingNick = null;
        });
    } else {
        superDisconnect.call(io, id, reason);
        disconnectingNick = null;
    }
};

/* hook into onJoin and onLeave to generate messages for respective rooms */
var overrideHandler = function (name, eventName) {
    var superHandler = io[name];
    io[name] = function(id, room) {
        superHandler.apply(io, [id, room]);
        room = room.split('/');
        room = room[room.length - 1];
        var client = io.sockets.socket(id);
        var emitEvent = function(nick) {
            if (room && nick) {
                io.sockets["in"](room).except(id).emit(eventName, {
                    nick: nick,
                    room: room
                });
            }
        }
        if (client) {
            client.get('nick', function(err, nick) {
                emitEvent(nick ? nick : disconnectingNick);
            });
        } else {
            emitEvent(disconnectingNick);
        }
    }
};
overrideHandler('onJoin', 'clientJoined');
overrideHandler('onLeave', 'clientLeft');

//var redis = require('socket.io/node_modules/redis');

io.configure(function () {
/*    var RedisStore = require('socket.io/lib/stores/redis');
    io.set('store', new RedisStore({
        redisPub: redis.createClient(),
        redisSub: redis.createClient(),
        redisClient: redis.createClient()
    }));
*/
});

io.sockets.on('connection', function (client) {
    client.nick = null;

    client.on("join", function (msg, fn) {
        var indicator = msg.room.substring(0,1);
        if (indicator === '@' || indicator === '#') {
            // only fragment and area chats for now
            client.join(msg.room);
            fn('end');
        } else {
            // '~' is the private room, nothing to do there
            fn(msg.room === '~' ? 'end' : 'error');
        }
        
    });

    client.on('leave', function (msg, fn) {
        client.leave(msg.room);
        fn('end');
    });

    client.on('message', function (msg, fn) {
        // if msg.nick is a number we always allow it
        // otherwise the nicks have to match
        if ((client.nick === msg.nick || +msg.nick > 0) &&
                client.manager.roomClients[client.id][client.namespace.name + '/' + msg.room] === true) {
            client.broadcast.to(msg.room).json.send(msg);
            fn(msg);
        } else {
            fn({
                nick : client.nick,
                room : msg.room,
                msg : 'failed to send "' + msg.msg + '".'
            })
        }
    });

    kwarque.emit('clientConnect', client);
});

exports.io = io;
