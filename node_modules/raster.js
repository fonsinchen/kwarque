"use strict";

(function(exports) {

var raster = {
    lon : {
        min : -20037508,
        max : 20037508,
        minRaster : 500,
        maxRaster : 10000000,
        multiplier : 16,
        levels: [],
        messageLevel : 1
    }, lat : {
        min : -20037508,
        max : 20037508,
        minRaster : 500,
        maxRaster : 10000000,
        multiplier : 16,
        levels: [],
        messageLevel : 1
    }, t : {
        min : -8.64e+12,
        max : 8.64e+12,
        minRaster : 3600,
        maxRaster : 1.0e+11,
        multiplier : 32,
        levels : [],
        messageLevel : 0
    }
}

var calcLevels = function(type) {
    var max = type.max;
    var min = type.min;
    while (max - min > type.minRaster) {
        if (max - min < type.maxRaster) {
            type.levels.push(Math.floor(max - min));
        }
        max /= type.multiplier;
        min /= type.multiplier;
    }
};

for (var type in raster) {
    if (raster.hasOwnProperty(type)) {
        calcLevels(raster[type]);
    }
}
console.log(raster);

var wrapAround = function(min, max, val1, val2) {
    var wrapped = false;
    if (val1 < min) {
        wrapped = true;
        val1 = max - min + val1;
    }
    if (val2 > max) {
        wrapped = true;
        val2 = min + val2 - max;
    }
    if (wrapped && val1 <= val2) {
        return [min, max];
    } else {
        return [val1, val2];
    }
}

exports.rasterize = function(type, a, b) {
    type = raster[type];
    var wrapped = wrapAround(type.min, type.max, Math.floor(a), Math.ceil(b));
    a = wrapped[0];
    b = wrapped[1];
    var prevA = Math.floor(a / type.levels[0]);    
    var prevB = Math.ceil(b / type.levels[0]);

    var i = 1;
    for (; i < type.levels.length; ++i) {
        var offsetA = Math.floor(a / type.levels[i]);
        var offsetB = Math.ceil(b / type.levels[i]);
        if (Math.abs(offsetB - offsetA) > 2) {
            var ret = [prevA  * type.levels[i - 1]];
            if (prevB - prevA > 1) {
                ret.push((prevA + prevB) / 2 * type.levels[i - 1]);
            }
            ret.push(prevB  * type.levels[i - 1]);
            return {level : i - 1, values : ret};
        }
        prevA = offsetA;
        prevB = offsetB;
    }
    if (offsetA === offsetB) {
        if (offsetB < type.max) {
            offsetB++;
        } else {
            offsetB = type.min;
        }
    }
    return {level : i - 1, values : [offsetA  * type.levels[i - 1], offsetB  * type.levels[i - 1]]};
}

exports.transform = function(type, intervals, targetLevel) {
    type = raster[type];
    var levelIntervals = intervals.values;
    var first = levelIntervals[0];
    var last = levelIntervals[levelIntervals.length - 1];
    var newIntervals = [];
    var offsetA = Math.floor(first / type.levels[targetLevel]);
    var offsetB = Math.ceil(last / type.levels[targetLevel]);
    var maxOffset = Math.ceil(type.max / type.levels[targetLevel]);
    var minOffset = Math.floor(type.min / type.levels[targetLevel]);
    for (var i = offsetA; i <= offsetB; ++i) {
        newIntervals.push(type.levels[targetLevel] * i);
        if (i === maxOffset) i = minOffset;
    }
    return {level : targetLevel, values : newIntervals};
}

exports.min = function(type) {return raster[type].min;};
exports.max = function(type) {return raster[type].max;};
exports.messageLevel = function(type) {return raster[type].messageLevel;};

})(typeof exports === 'undefined' ? KWARQUE.raster = {} : exports);